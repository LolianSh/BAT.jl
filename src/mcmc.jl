# This file is a part of BAT.jl, licensed under the MIT License (MIT).


abstract type AbstractMCMCState end


sample_available(state::AbstractMCMCState) = sample_available(state, Val(:complete))

current_sample(state::AbstractMCMCState) = current_sample(state, Val(:complete))



abstract type MCMCAlgorithm{S<:AbstractMCMCState} end


abstract type AbstractMCMCSample end
export AbstractMCMCSample



mutable struct MCMCSample{
    P<:Real,
    T<:Real,
    W<:Real
} <: AbstractMCMCSample
    params::Vector{P}
    log_value::T
    weight::W
end

export MCMCSample


Base.length(s::MCMCSample) = length(s.params)

Base.similar(s::MCMCSample{P,T,W}) where {P,T,W} =
    MCMCSample{P,T,W}(oob(s.params), convert(T, NaN), zero(W))

import Base.==
==(A::MCMCSample, B::MCMCSample) =
    A.params == B.params && A.log_value == B.log_value && A.weight == B.weight


function Base.copy!(dest::MCMCSample, src::MCMCSample) 
    copy!(dest.params, src.params)
    dest.log_value = src.log_value
    dest.weight = src.weight
    dest
end


nparams(s::MCMCSample) = length(s)



struct MCMCChainInfo
    id::Int
    cycle::Int
    tuned::Bool
    converged::Bool
end

export MCMCChainInfo

MCMCChainInfo(id::Int, cycle::Int = 0) = MCMCChainInfo(id, cycle, false, false)


next_cycle(info::MCMCChainInfo) =
    MCMCChainInfo(info.id, info.cycle + 1, info.tuned, info.converged)

set_tuned(info::MCMCChainInfo, value::Bool) =
    MCMCChainInfo(info.id, info.cycle, value, info.converged)

set_converged(info::MCMCChainInfo, value::Bool) =
    MCMCChainInfo(info.id, info.cycle, info.tuned, value)



mutable struct MCMCChain{
    A<:MCMCAlgorithm,
    T<:AbstractTargetSubject,
    S<:AbstractMCMCState
}
    algorithm::A
    target::T
    state::S
    info::MCMCChainInfo
end

export MCMCChain


nparams(chain::MCMCChain) = nparams(chain.target)



# struct MCMCCallback{F}
#     f::F
#     max_level::Int
# end
# 
# export MCMCCallback
# 
# MCMCCallback() = MCMCCallback(identity, 1)
# 
# Base.convert(::Type{MCMCCallback}, x::MCMCCallback) = x
# 
# Base.convert(::Type{MCMCCallback}, f) = MCMCCallback(f, 1)
# 
# 
# function (callback::MCMCCallback)(level, args...)
#     if (level <= callback.max_level)
#         callback.f(args...)
#     end
# end



"""
    AbstractMCMCCallback <: Function

Subtypes (here, `X`) must support

    (::X)(level::Integer, chain::MCMCChain) => nothing
    (::X)(level::Integer, tuner::AbstractMCMCTuner) => nothing

to be compabtible with `mcmc_iterate!`, `mcmc_auto_tune!`, etc.
"""
abstract type AbstractMCMCCallback <: Function end
export AbstractMCMCCallback



"""
    mcmc_callback(
        output::Union{AbstractMCMCStats,MCMCSampleVector,...},
        max_level::Integer = 1
    )::AbstractMCMCCallback

Creates a callback function/object compatible with `mcmc_iterate!`,
`mcmc_auto_tune!`, etc., that will fill `output` with samples
generated by the chain.
"""
function mcmc_callback end
export mcmc_callback
