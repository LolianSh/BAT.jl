# This file is a part of BAT.jl, licensed under the MIT License (MIT).


abstract type AbstractMCMCState end


sample_available(state::AbstractMCMCState) = sample_available(state, Val(:complete))

current_sample(state::AbstractMCMCState) = current_sample(state, Val(:complete))


function Base.push!(xs::DensitySampleVector, state::AbstractMCMCState)
    if sample_available(state, Val(:any))
        push!(xs, current_sample(state, Val(:any)))
    end
    xs
end



abstract type MCMCAlgorithm{S<:AbstractMCMCState} <: BATAlgorithm end



mutable struct MCMCChain{
    A<:MCMCAlgorithm,
    T<:AbstractTargetSubject,
    S<:AbstractMCMCState,
    R<:AbstractRNG
}
    algorithm::A
    target::T
    state::S
    rng::R
    id::Int
    cycle::Int
    tuned::Bool
    converged::Bool
end

export MCMCChain


nparams(chain::MCMCChain) = nparams(chain.target)

sample_available(chain::MCMCChain, status::Val = Val(:complete)) = sample_available(chain.state, status)

current_sample(chain::MCMCChain, status::Val = Val(:complete)) = current_sample(chain.state, status)

current_sampleno(chain::MCMCChain) = current_sampleno(chain.state)


function DensitySampleVector(chain::MCMCChain)
    P = eltype(chain.state.current_sample.params)
    T = typeof(chain.state.current_sample.log_value)
    W = typeof(chain.state.current_sample.weight)

    m = size(chain.state.current_sample.params, 1)
    DensitySampleVector(ExtendableArray{P}(m, 0), Vector{T}(0), Vector{W}(0))
end

function Base.push!(xs::DensitySampleVector, chain::MCMCChain)
    push!(xs, chain.state)
    chain
end


function mcmc_iterate!(
    callbacks,
    chains::AbstractVector{<:MCMCChain},
    exec_context::ExecContext = ExecContext();
    kwargs...
)
    cbv = mcmc_callback_vector(callbacks, chains)
    mcmc_iterate!.(cbv, chains, exec_context; kwargs...)
    chains
end


struct MCMCChainSpec{
    A<:MCMCAlgorithm,
    T<:AbstractTargetSubject,
    Q<:ProposalDistSpec,
    R<:AbstractRNGSeed
}
    algorithm::A
    target::T
    pdistspec::Q
    rngspec::R
end

export MCMCChainSpec

MCMCChainSpec(
    algorithm::MCMCAlgorithm,
    target::AbstractTargetSubject,
    pdistspec::ProposalDistSpec = MvTDistProposalSpec()
) = MCMCChainSpec(algorithm, target, pdistspec, Philox4xSeed())


function (spec::MCMCChainSpec)(
    id::Integer,
    exec_context::ExecContext = ExecContext()
)
    P = float(eltype(spec.target.bounds))
    m = nparams(spec.target)
    rng = spec.rngspec()
    MCMCChain(
        spec.algorithm,
        spec.target,
        spec.pdistspec(P, m),
        id,
        rng,
        Vector{P}(),
        exec_context,
    )
end


function (spec::MCMCChainSpec)(
    ids::AbstractVector,
    exec_context::ExecContext = ExecContext()
)
    spec.(ids, exec_context)
end



"""
    AbstractMCMCCallback <: Function

Subtypes (here, `X`) must support

    (::X)(level::Integer, chain::MCMCChain) => nothing
    (::X)(level::Integer, tuner::AbstractMCMCTuner) => nothing

to be compabtible with `mcmc_iterate!`, `mcmc_tune_burnin!`, etc.
"""
abstract type AbstractMCMCCallback <: Function end
export AbstractMCMCCallback



"""
    mcmc_callback(
        output::Union{Any,AbstractMCMCStats,DensitySampleVector,...},
        max_level::Integer = 1
    )::AbstractMCMCCallback

Creates a callback function/object compatible with `mcmc_iterate!`,
`mcmc_tune_burnin!`, etc., that will fill `output` with samples
generated by the chain. Depending on the output, `max_level` may be ignored.

    mcmc_callback(fs::Tuple)::AbstractMCMCCallback

Creates a callback that broadcasts it's arguments over all functions in
the tuple `fs`.

    mcmc_callback(f::Function) = f

This variant assumes that `f` is already a compabible callback function.
"""
function mcmc_callback end
export mcmc_callback

mcmc_callback(f::Function) = f


function mcmc_callback_vector(V::Vector{<:Function}, chains::AbstractVector{<:MCMCChain})
    if eachindex(V) != eachindex(chains)
        throw(DimensionMismatch("Indices of callback vector incompatible with number of MCMC chains"))
    end
    V
end

mcmc_callback_vector(V::Vector, chains::AbstractVector{<:MCMCChain}) =
    mcmc_callback_vector(mcmc_callback.(V), chains)

mcmc_callback_vector(x::Any, chains::AbstractVector{<:MCMCChain}) =
    mcmc_callback_vector(map(_ -> mcmc_callback(x), chains), chains)



struct MCMCMultiCallback{FT<:Tuple} <: AbstractMCMCCallback
    max_level::Int
    funcs::FT
end


function (cb::MCMCMultiCallback)(level::Integer, obj::Any)
    if level <= cb.max_level
        for f in cb.funcs
            f(level, obj)
        end
    end
    nothing
end


function mcmc_callback(max_level::Integer, funcs::Tuple)
    cb_funcs = map(f -> mcmc_callback(f), funcs)
    MCMCMultiCallback(max_level, cb_funcs)
end

mcmc_callback(max_level::Integer, f, fs...) = mcmc_callback(max_level, (f, fs...))

mcmc_callback(funcs::Tuple) = mcmc_callback(typemax(Int), funcs)

mcmc_callback(f, fs...) = mcmc_callback((f, fs...))



struct MCMCPushCallback{T} <: AbstractMCMCCallback
    max_level::Int
    target::T
end

MCMCPushCallback(target) = MCMCPushCallback(1, target)

function (cb::MCMCPushCallback)(level::Integer, chain::MCMCChain)
    if (level <= cb.max_level)
        push!(cb.target, chain)
    end
    nothing
end

(cb::MCMCPushCallback)(level::Integer, obj::Any) = nothing
